---
title: "EDA Netflix Dataset con pandas Jupyter"
---

# Tarea 3: EDA Netflix con Visualizaciones - Fill in the Blanks
## G1: Joaqu√≠n Batista, Milagros Cancela, Valent√≠n Rodr√≠guez, Alexia Aurrecoechea, Nahuel L√≥pez
### UT1: An√°lisis Exploratorio de Datos | Pr√°ctica Guiada

---

## üéØ Objetivos B√°sicos
- Aprender a cargar y explorar datasets reales  
- Crear visualizaciones efectivas con **matplotlib** y **seaborn**  
- Identificar patrones y tendencias en los datos  
- Interpretar gr√°ficos de forma correcta  

---

## üìã Lo que necesitas saber ANTES de empezar
- Conceptos b√°sicos de **Python** y **pandas**  
- Idea general de qu√© son las visualizaciones  
- Curiosidad por descubrir patrones en datos reales  

---

## üìã Contexto de Negocio (CRISP-DM: Business Understanding)

### üîó Referencias oficiales:
- [Dataset Netflix - Kaggle](https://www.kaggle.com/shivamb/netflix-shows)  
- [Documentaci√≥n pandas](https://pandas.pydata.org/docs/)  
- [Documentaci√≥n seaborn](https://seaborn.pydata.org/)  

### Caso de negocio
- **Problema**: Netflix necesita entender mejor su cat√°logo para tomar decisiones estrat√©gicas.  
- **Objetivo**: Analizar patrones en el contenido, pa√≠ses de origen y tendencias temporales.  
- **Variables**: Tipo de contenido, pa√≠s, fecha de lanzamiento, rating, g√©neros, etc.  
- **Valor para el negocio**: Optimizar la adquisici√≥n de contenido y entender audiencias globales.  

```python
# Importar librer√≠as que vamos a usar

#Arreglos por compatibilidad con versiones de Python
import PIL, matplotlib
print("Pillow:", PIL.__version__)
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_theme()
plt.plot([1,2,3],[1,4,9]); plt.title("OK"); plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Configurar el estilo de visualizaciones
plt.style.use("classic")  # establecer estilo visual (ej: 'default', 'seaborn', 'classic')
sns.set_palette("husl")  # definir paleta de colores (ej: 'husl', 'Set1', 'viridis')
plt.rcParams['figure.figsize'] = (10, 6)  # tama√±o por defecto

print("‚úÖ Setup completo!")
```

```python
# === CARGAR DATOS DE NETFLIX ===

# 1. Cargar el dataset desde una URL
url = "https://raw.githubusercontent.com/swapnilg4u/Netflix-Data-Analysis/refs/heads/master/netflix_titles.csv"
df = pd.read_csv(url)  # funci√≥n para leer archivos CSV desde URL o archivo local

print("üé¨ DATASET: Netflix Titles")
print(f"   üìä Forma: {df.shape}")
print(f"   üìã Columnas: {list(df.columns)}")

# 2. Explorar los datos b√°sicamente
print("\nüîç Primeras 5 filas:")
print(df.head())  # m√©todo para mostrar las primeras filas del DataFrame

# 3. Informaci√≥n sobre tipos de datos y memoria
print("\nüìã INFORMACI√ìN GENERAL:")
print(df.info())  # m√©todo que muestra tipos de datos, memoria y valores no nulos

# 4. Estad√≠sticas b√°sicas para columnas num√©ricas
print("\nüìä ESTAD√çSTICAS B√ÅSICAS:")
print(df.describe)  # m√©todo que calcula estad√≠sticas descriptivas (mean, std, min, max, etc.)
```

```python
# === DETECTAR Y VISUALIZAR DATOS FALTANTES ===

# 1. Calcular datos faltantes por columna
missing_data = df.isna().sum().sort_values(ascending=False)  # detectar valores nulos y contar por columna
missing_percent = (df.isna().sum() / len(df) * 100).sort_values(ascending=False)  # calcular porcentaje de nulos

print("‚ùå DATOS FALTANTES:")
print(missing_data[missing_data > 0])
print("\nüìä PORCENTAJES:")
print(missing_percent[missing_percent > 0])

# 2. Crear visualizaci√≥n de datos faltantes
plt.figure(figsize=(12, 6))

# Subplot 1: Gr√°fico de barras de datos faltantes
plt.subplot(1, 2, 1)
sns.barplot(x=missing_percent[missing_percent > 0].values,  # funci√≥n para crear barras horizontales
            y=missing_percent[missing_percent > 0].index,
            palette='Reds_r')
plt.title('Porcentaje de Datos Faltantes por Columna')
plt.xlabel('Porcentaje (%)')

# Subplot 2: Heatmap de datos faltantes
plt.subplot(1, 2, 2)
sns.heatmap(df.isnull(), cbar=True, cmap='viridis')  # funci√≥n para crear mapa de calor de valores booleanos
plt.title('Patr√≥n de Datos Faltantes')
plt.xticks(rotation=45)

plt.tight_layout()
plt.show()  # funci√≥n para mostrar/renderizar los gr√°ficos en pantalla
```

```python
# === DETECCI√ìN DE OUTLIERS Y ANOMAL√çAS ===

# 1. Analizar a√±os de lanzamiento at√≠picos
print("üîç AN√ÅLISIS DE OUTLIERS EN A√ëOS:")
df['release_year_clean'] = pd.to_numeric(df['release_year'], errors='coerce')
year_stats = df['release_year_clean'].describe()
print(year_stats)

# Identificar a√±os sospechosos
very_old = df[df['release_year_clean'] < 1950]
future_releases = df[df['release_year_clean'] > 2025]

print(f"\n‚ö†Ô∏è Contenido muy antiguo (< 1950): {len(very_old)} t√≠tulos")
if len(very_old) > 0:
    print("Ejemplos:")
    print(very_old[['title', 'release_year', 'type']].head())

print(f"\n‚ö†Ô∏è Lanzamientos futuros (> 2025): {len(future_releases)} t√≠tulos")
if len(future_releases) > 0:
    print("Ejemplos:")
    print(future_releases[['title', 'release_year', 'type']].head())

# 2. Crear visualizaciones para detectar outliers
fig, axes = plt.subplots(2, 2, figsize=(15, 10))

# Gr√°fico 1: Box plot para detectar outliers en a√±os
sns.boxplot(data=df, y='release_year_clean', ax=axes[0, 0])  # funci√≥n para mostrar outliers con cajas
axes[0, 0].set_title('Box Plot - A√±os de Lanzamiento (Outliers)')
axes[0, 0].set_ylabel('A√±o de Lanzamiento')

# Gr√°fico 2: Histograma de a√±os para ver distribuci√≥n
axes[0, 1].hist(df['release_year_clean'].dropna(), bins=50, alpha=0.7, color='skyblue', edgecolor='black')  # histograma con muchos bins
axes[0, 1].set_title('Distribuci√≥n de A√±os de Lanzamiento')
axes[0, 1].set_xlabel('A√±o')
axes[0, 1].set_ylabel('Frecuencia')
axes[0, 1].axvline(df['release_year_clean'].mean(), color='red', linestyle='--', label='Media')
axes[0, 1].legend()

# Gr√°fico 3: An√°lisis de t√≠tulos duplicados
title_counts = df['title'].value_counts()  # contar frecuencias de t√≠tulos
duplicated_titles = title_counts[title_counts > 1]

print(f"\nüîÑ T√çTULOS DUPLICADOS: {len(duplicated_titles)} t√≠tulos aparecen m√∫ltiples veces")
if len(duplicated_titles) > 0:
    top_duplicates = duplicated_titles.head(10)
    sns.barplot(y=top_duplicates.index, x=top_duplicates.values, ax=axes[1, 0], palette='Reds')  # barras horizontales
    axes[1, 0].set_title('Top 10 T√≠tulos Duplicados')
    axes[1, 0].set_xlabel('Cantidad de Apariciones')
else:
    axes[1, 0].text(0.5, 0.5, 'No se encontraron\nt√≠tulos duplicados', 
                    ha='center', va='center', transform=axes[1, 0].transAxes)
    axes[1, 0].set_title('T√≠tulos Duplicados - Sin Datos')

# Gr√°fico 4: Longitud de t√≠tulos (outliers en texto)
df['title_length'] = df['title'].str.len()
title_length_stats = df['title_length'].describe()

sns.boxplot(data=df, y='title_length', ax=axes[1, 1])  # box plot para longitud de t√≠tulos
axes[1, 1].set_title('Box Plot - Longitud de T√≠tulos')
axes[1, 1].set_ylabel('Caracteres en el T√≠tulo')

# Identificar t√≠tulos extremadamente largos o cortos
very_long_titles = df[df['title_length'] > df['title_length'].quantile(0.99)]
very_short_titles = df[df['title_length'] < 5]

print(f"\nüìè T√çTULOS EXTREMOS:")
print(f"   Muy largos (> percentil 99): {len(very_long_titles)} t√≠tulos")
if len(very_long_titles) > 0:
    print(f"   Ejemplo m√°s largo: '{very_long_titles.loc[very_long_titles['title_length'].idxmax(), 'title']}'")

print(f"   Muy cortos (< 5 caracteres): {len(very_short_titles)} t√≠tulos")
if len(very_short_titles) > 0:
    print("   Ejemplos:")
    print(very_short_titles[['title', 'title_length', 'type']].head())

plt.tight_layout()
plt.show()

print("‚úÖ An√°lisis de outliers completado!")
```

```python
# === AN√ÅLISIS DE TIPOS DE CONTENIDO ===

# 1. Calcular frecuencias
type_counts = df['type'].value_counts()  # m√©todo para contar frecuencias de cada categor√≠a √∫nica
type_percent = df['type'].value_counts(normalize=True) * 100  # mismo m√©todo pero calculando porcentajes

print("üé≠ TIPOS DE CONTENIDO:")
print(type_counts)
print(f"\nPorcentajes:")
print(type_percent)

# 2. Crear visualizaciones m√∫ltiples
fig, axes = plt.subplots(2, 2, figsize=(15, 10))

# Gr√°fico 1: Countplot b√°sico
sns.countplot(data=df, x='type', ax=axes[0, 0], palette='Set2')  # funci√≥n para contar y graficar categor√≠as
axes[0, 0].set_title('Distribuci√≥n: Movies vs TV Shows')
axes[0, 0].set_ylabel('Cantidad')

# Gr√°fico 2: Pie chart
axes[0, 1].pie(type_counts.values, labels=type_counts.index,  # funci√≥n para crear gr√°fico circular/torta
               autopct='%1.1f%%', startangle=90, colors=['skyblue', 'lightcoral'])
axes[0, 1].set_title('Proporci√≥n Movies vs TV Shows')

# Gr√°fico 3: Barplot horizontal
sns.barplot(y=type_counts.index, x=type_counts.values, ax=axes[1, 0], palette='viridis')  # funci√≥n para barras horizontales
axes[1, 0].set_title('Cantidad por Tipo (Horizontal)')
axes[1, 0].set_xlabel('Cantidad')

# Gr√°fico 4: Donut chart (m√°s avanzado)
wedges, texts, autotexts = axes[1, 1].pie(type_counts.values, labels=type_counts.index,  # misma funci√≥n de torta para donut
                                          autopct='%1.1f%%', startangle=90,
                                          colors=['gold', 'lightgreen'])
# Crear el hueco del donut
centre_circle = plt.Circle((0,0), 0.70, fc='white')
axes[1, 1].add_artist(centre_circle)
axes[1, 1].set_title('Donut Chart - Tipos de Contenido')

plt.tight_layout()
plt.show()
```
```python
# === AN√ÅLISIS DE TENDENCIAS TEMPORALES ===

# 1. Preparar datos temporales
df['release_year'] = pd.to_numeric(df['release_year'], errors='coerce')  # convertir a num√©rico, NaN si no es posible
yearly_releases = df['release_year'].value_counts().sort_index()  # contar frecuencias por a√±o y ordenar

# Filtrar a√±os recientes para mejor visualizaci√≥n
recent_years = yearly_releases[yearly_releases.index >= 2000]

# 2. Crear visualizaciones temporales m√∫ltiples
fig, axes = plt.subplots(2, 2, figsize=(16, 12))

# Gr√°fico 1: L√≠nea temporal
axes[0, 0].plot(recent_years.index, recent_years.values,  # funci√≥n para crear l√≠neas conectando puntos
                marker='o', linewidth=2, markersize=4, color='darkblue')
axes[0, 0].set_title('Cantidad de Contenido por A√±o (2000-2021)')
axes[0, 0].set_xlabel('A√±o')
axes[0, 0].set_ylabel('Cantidad de T√≠tulos')
axes[0, 0].grid(True, alpha=0.3)

# Gr√°fico 2: √Årea bajo la curva
axes[0, 1].fill_between(recent_years.index, recent_years.values,  # funci√≥n para rellenar √°rea bajo la l√≠nea
                  alpha=0.7, color='lightcoral')
axes[0, 1].set_title('√Årea - Lanzamientos por A√±o')
axes[0, 1].set_xlabel('A√±o')
axes[0, 1].set_ylabel('Cantidad')

# Gr√°fico 3: An√°lisis por tipo de contenido
df_recent = df[df['release_year'] >= 2010]
yearly_by_type = df_recent.groupby(['release_year', 'type']).size().unstack(fill_value=0)

yearly_by_type.plot(kind='bar', ax=axes[1, 0],  # tipo de gr√°fico con barras lado a lado (no apiladas)
                    color=['skyblue', 'lightgreen'], alpha=0.8)
axes[1, 0].set_title('Lanzamientos por Tipo (2010-2021)')
axes[1, 0].set_xlabel('A√±o')
axes[1, 0].set_ylabel('Cantidad')
axes[1, 0].legend(title='Tipo')

# Gr√°fico 4: Heatmap de lanzamientos por d√©cada y tipo
df['decade'] = (df['release_year'] // 10) * 10
decade_type = df.groupby(['decade', 'type']).size().unstack(fill_value=0)
sns.heatmap(decade_type, annot=True, fmt='d', ax=axes[1, 1], cmap='YlOrRd')  # funci√≥n para mapa de calor con anotaciones
axes[1, 1].set_title('Heatmap: Lanzamientos por D√©cada y Tipo')

plt.tight_layout()
plt.show()

print("üìÖ A√ëOS CON M√ÅS LANZAMIENTOS:")
print(yearly_releases.tail(10))
```

```python
# === AN√ÅLISIS DE PA√çSES CON VISUALIZACIONES ===

# 1. Preparar datos de pa√≠ses (limpiar y separar pa√≠ses m√∫ltiples)
df_countries = df.dropna(subset=['country']).copy()

# Separar pa√≠ses que est√°n separados por comas
countries_expanded = df_countries['country'].str.split(', ').explode()
country_counts = countries_expanded.value_counts().head(20)

print("üåç TOP 20 PA√çSES CON M√ÅS CONTENIDO:")
print(country_counts)

# 2. Crear visualizaciones geogr√°ficas
fig, axes = plt.subplots(2, 2, figsize=(18, 12))

# Gr√°fico 1: Top 15 pa√≠ses - barras horizontales
top_15_countries = country_counts.head(15)
sns.barplot(y=top_15_countries.index, x=top_15_countries.values,  # funci√≥n para barras horizontales
           ax=axes[0, 0], palette='viridis')
axes[0, 0].set_title('Top 15 Pa√≠ses con M√°s Contenido')
axes[0, 0].set_xlabel('Cantidad de T√≠tulos')

# Gr√°fico 2: Treemap simulado con scatter
top_10 = country_counts.head(10)
colors = plt.cm.Set3(np.linspace(0, 1, len(top_10)))
axes[0, 1].scatter(range(len(top_10)), top_10.values,  # funci√≥n para gr√°fico de burbujas/puntos
                  s=top_10.values*3, c=colors, alpha=0.7)
for i, (country, count) in enumerate(top_10.items()):
    axes[0, 1].annotate(f'{country}\n({count})', 
                       (i, count), ha='center', va='center')
axes[0, 1].set_title('Bubble Chart - Top 10 Pa√≠ses')
axes[0, 1].set_xticks(range(len(top_10)))
axes[0, 1].set_xticklabels(top_10.index, rotation=45)

# Gr√°fico 3: An√°lisis de contenido por pa√≠s y tipo
top_countries = country_counts.head(10).index
df_top_countries = df_countries[df_countries['country'].isin(top_countries)]
country_type = df_top_countries.groupby(['country', 'type']).size().unstack(fill_value=0)

country_type.plot(kind='bar', ax=axes[1, 0],  # tipo de gr√°fico con barras agrupadas lado a lado
                  color=['lightblue', 'salmon'], width=0.8)
axes[1, 0].set_title('Movies vs TV Shows por Pa√≠s (Top 10)')
axes[1, 0].set_ylabel('Cantidad')
axes[1, 0].legend(title='Tipo')
axes[1, 0].tick_params(axis='x', rotation=45)

# Gr√°fico 4: Heatmap de correlaci√≥n entre pa√≠ses principales
# Crear matriz de co-ocurrencia de pa√≠ses
from itertools import combinations
co_occurrence = {}
for countries_str in df_countries['country']:
    if pd.notna(countries_str) and ',' in countries_str:
        countries_list = [c.strip() for c in countries_str.split(',')]
        for c1, c2 in combinations(countries_list, 2):
            if c1 in top_10.index and c2 in top_10.index:
                key = tuple(sorted([c1, c2]))
                co_occurrence[key] = co_occurrence.get(key, 0) + 1

# Crear matriz para heatmap
co_matrix = np.zeros((len(top_10), len(top_10)))
for i, c1 in enumerate(top_10.index):
    for j, c2 in enumerate(top_10.index):
        if i != j:
            key = tuple(sorted([c1, c2]))
            co_matrix[i, j] = co_occurrence.get(key, 0)

sns.heatmap(co_matrix, annot=True, fmt='.0f',  # funci√≥n para mapa de calor (formato .0f para n√∫meros flotantes)
           xticklabels=top_10.index, yticklabels=top_10.index,
           ax=axes[1, 1], cmap='Reds')
axes[1, 1].set_title('Co-producci√≥n entre Pa√≠ses')
axes[1, 1].tick_params(axis='x', rotation=45)
axes[1, 1].tick_params(axis='y', rotation=0)

plt.tight_layout()
plt.show()
```


```python
# === AN√ÅLISIS DE RATINGS Y G√âNEROS ===

# 1. Preparar datos de ratings
rating_counts = df['rating'].value_counts().head(10)

print("üîû TOP 10 RATINGS M√ÅS COMUNES:")
print(rating_counts)

# 2. Crear dashboard de ratings
fig, axes = plt.subplots(2, 3, figsize=(20, 12))

# Gr√°fico 1: Countplot de ratings
sns.countplot(data=df, x='rating', order=rating_counts.index, ax=axes[0, 0], palette='Set1')
axes[0, 0].set_title('Distribuci√≥n de Ratings')
axes[0, 0].tick_params(axis='x', rotation=45)

# Gr√°fico 2: Ratings por tipo de contenido
sns.countplot(data=df, x='rating', hue='type',  # misma funci√≥n pero separando por otra variable (hue)
           order=rating_counts.index, ax=axes[0, 1])
axes[0, 1].set_title('Ratings por Tipo de Contenido')
axes[0, 1].tick_params(axis='x', rotation=45)
axes[0, 1].legend(title='Tipo')

# Gr√°fico 3: Pie chart de ratings principales
top_5_ratings = rating_counts.head(5)
axes[0, 2].pie(top_5_ratings.values, labels=top_5_ratings.index,  # funci√≥n para gr√°fico circular/torta
               autopct='%1.1f%%', startangle=90)
axes[0, 2].set_title('Top 5 Ratings - Proporci√≥n')

# Gr√°fico 4: Box plot de a√±os de lanzamiento por rating
df_clean = df.dropna(subset=['rating', 'release_year'])
top_ratings = rating_counts.head(6).index
df_top_ratings = df_clean[df_clean['rating'].isin(top_ratings)]

sns.boxplot(data=df_top_ratings, x='rating', y='release_year',  # funci√≥n para mostrar distribuci√≥n con cajas y bigotes
           order=top_ratings, ax=axes[1, 0])
axes[1, 0].set_title('Distribuci√≥n de A√±os por Rating')
axes[1, 0].tick_params(axis='x', rotation=45)

# Gr√°fico 5: Violin plot alternativo
sns.violinplot(data=df_top_ratings, x='rating', y='release_year',  # funci√≥n para mostrar densidad como "violines"
           order=top_ratings, ax=axes[1, 1], palette='muted')
axes[1, 1].set_title('Densidad de A√±os por Rating')
axes[1, 1].tick_params(axis='x', rotation=45)

# Gr√°fico 6: Heatmap de rating vs d√©cada
df_clean['decade'] = (df_clean['release_year'] // 10) * 10
rating_decade = df_clean.groupby(['rating', 'decade']).size().unstack(fill_value=0)
# Filtrar solo ratings principales y d√©cadas recientes
rating_decade_filtered = rating_decade.loc[top_ratings, rating_decade.columns >= 1980]

sns.heatmap(rating_decade_filtered, annot=True, fmt='d',  # funci√≥n para mapa de calor con valores enteros
           ax=axes[1, 2], cmap='Blues')
axes[1, 2].set_title('Heatmap: Rating vs D√©cada')
axes[1, 2].tick_params(axis='x', rotation=45)

plt.tight_layout()
plt.show()
```

```python
# === CREAR DASHBOARD FINAL INTERACTIVO ===

# 1. Calcular estad√≠sticas finales
total_titles = len(df)
total_movies = len(df[df['type'] == 'Movie'])
total_shows = len(df[df['type'] == 'TV Show'])
latest_year = df['release_year'].max()
oldest_year = df['release_year'].min()

print(f"RESUMEN EJECUTIVO NETFLIX:")
print(f"   Total de t√≠tulos: {total_titles:,}")
print(f"   Pel√≠culas: {total_movies:,} ({total_movies/total_titles*100:.1f}%)")
print(f"   Series: {total_shows:,} ({total_shows/total_titles*100:.1f}%)")
print(f"   Rango de a√±os: {oldest_year} - {latest_year}")

# 2. Crear figura principal con subplots
fig = plt.figure(figsize=(20, 15))
gs = fig.add_gridspec(3, 4, hspace=0.3, wspace=0.3)

# Dashboard panel 1: Tipos (grande)
ax1 = fig.add_subplot(gs[0, :2])
type_data = df['type'].value_counts()
colors = ['#FF6B6B', '#4ECDC4']
wedges, texts, autotexts = ax1.pie(type_data.values, labels=type_data.index,  # funci√≥n para gr√°fico de torta en dashboard
                                   autopct='%1.1f%%', startangle=90,
                                   colors=colors, textprops={'fontsize': 12})
ax1.set_title('Distribuci√≥n Movies vs TV Shows', fontsize=14, fontweight='bold')

# Dashboard panel 2: Timeline
ax2 = fig.add_subplot(gs[0, 2:])
yearly = df.groupby('release_year').size()
recent_years = yearly[yearly.index >= 2000]
ax2.fill_between(recent_years.index, recent_years.values, color='#FF6B6B', alpha=0.7)  # funci√≥n para rellenar √°rea bajo curva
ax2.plot(recent_years.index, recent_years.values, color='darkred', linewidth=2)
ax2.set_title('Evoluci√≥n Temporal (2000+)', fontsize=14, fontweight='bold')
ax2.set_xlabel('A√±o')
ax2.set_ylabel('T√≠tulos Lanzados')
ax2.grid(True, alpha=0.3)

# Dashboard panel 3: Top pa√≠ses
ax3 = fig.add_subplot(gs[1, :2])
country_clean = df.dropna(subset=['country'])['country'].str.split(', ').explode()
top_countries = country_clean.value_counts().head(10)
sns.barplot(y=top_countries.index, x=top_countries.values, ax=ax3, palette='viridis')  # funci√≥n para barras horizontales
ax3.set_title('Top 10 Pa√≠ses Productores', fontsize=14, fontweight='bold')
ax3.set_xlabel('Cantidad de T√≠tulos')

# Dashboard panel 4: Ratings
ax4 = fig.add_subplot(gs[1, 2:])
top_ratings = df['rating'].value_counts().head(8)
sns.countplot(data=df[df['rating'].isin(top_ratings.index)],  # funci√≥n para contar categor√≠as separadas por hue
           x='rating', hue='type', order=top_ratings.index, ax=ax4)
ax4.set_title('Ratings por Tipo de Contenido', fontsize=14, fontweight='bold')
ax4.tick_params(axis='x', rotation=45)
ax4.legend(title='Tipo')

# Dashboard panel 5: Heatmap temporal (full width)
ax5 = fig.add_subplot(gs[2, :])
df['decade'] = (df['release_year'] // 10) * 10
year_type_decade = df.groupby(['decade', 'type']).size().unstack(fill_value=0)
sns.heatmap(year_type_decade.T, annot=True, fmt='d', ax=ax5,  # funci√≥n para mapa de calor transpuesto (.T)
           cmap='YlOrRd', cbar_kws={'label': 'Cantidad de T√≠tulos'})
ax5.set_title('Evoluci√≥n por D√©cadas y Tipo de Contenido', fontsize=14, fontweight='bold')
ax5.set_xlabel('D√©cada')
ax5.set_ylabel('Tipo de Contenido')

# Guardar el dashboard
plt.suptitle('NETFLIX CONTENT ANALYSIS DASHBOARD', fontsize=18, fontweight='bold', y=0.95)
plt.savefig(f'netflix_dashboard.png', dpi=300, bbox_inches='tight')  # funci√≥n para guardar figura como archivo
plt.show()

print("\n‚úÖ Dashboard guardado como 'netflix_dashboard.png'")
```

```python
# === AN√ÅLISIS AVANZADO DE G√âNEROS ===

# 1. Separar g√©neros que est√°n en lista separada por comas
genres_expanded = df.dropna(subset=['listed_in'])['listed_in'].str.split(', ').explode()
top_genres = genres_expanded.value_counts().head(15)  # contar frecuencias de g√©neros y tomar top 15

print("üé¨ TOP 15 G√âNEROS M√ÅS POPULARES:")
print(top_genres)

# 2. Crear visualizaci√≥n de g√©neros
fig, axes = plt.subplots(2, 2, figsize=(16, 10))

# Word cloud simulado con scatter
axes[0, 0].scatter(range(len(top_genres)), top_genres.values,  # funci√≥n para gr√°fico de burbujas (scatter)
                  s=top_genres.values*2, alpha=0.6, c=range(len(top_genres)), cmap='viridis')
for i, (genre, count) in enumerate(top_genres.items()):
    axes[0, 0].annotate(genre, (i, count), ha='center', va='center', fontsize=8)
axes[0, 0].set_title('Bubble Chart - G√©neros Populares')
axes[0, 0].set_xticks([])

# Barras horizontales de g√©neros
sns.barplot(y=top_genres.head(10).index, x=top_genres.head(10).values,  # funci√≥n para barras horizontales
           ax=axes[0, 1], palette='Set2')
axes[0, 1].set_title('Top 10 G√©neros')
axes[0, 1].set_xlabel('Cantidad')

# An√°lisis de duraci√≥n de pel√≠culas
movies_df = df[df['type'] == 'Movie'].copy()
movies_df['duration_min'] = movies_df['duration'].str.extract('(\d+)').astype(float)

axes[1, 0].hist(movies_df['duration_min'], bins=30, alpha=0.7, color='lightcoral', edgecolor='black')  # funci√≥n para histograma de frecuencias
axes[1, 0].set_title('Distribuci√≥n Duraci√≥n Pel√≠culas')
axes[1, 0].set_xlabel('Duraci√≥n (minutos)')
axes[1, 0].set_ylabel('Frecuencia')
axes[1, 0].axvline(movies_df['duration_min'].mean(), color='red', linestyle='--', 
                   label=f'Media: {movies_df["duration_min"].mean():.0f} min')
axes[1, 0].legend()

# An√°lisis de temporadas de series
tv_shows_df = df[df['type'] == 'TV Show'].copy()
tv_shows_df['seasons'] = tv_shows_df['duration'].str.extract('(\d+)').astype(float)

axes[1, 1].hist(tv_shows_df['seasons'], bins=range(1, 20), alpha=0.7, color='lightblue', edgecolor='black')  # funci√≥n para histograma con bins personalizados
axes[1, 1].set_title('Distribuci√≥n Temporadas TV Shows')
axes[1, 1].set_xlabel('N√∫mero de Temporadas')
axes[1, 1].set_ylabel('Frecuencia')
axes[1, 1].axvline(tv_shows_df['seasons'].mean(), color='blue', linestyle='--',
                   label=f'Media: {tv_shows_df["seasons"].mean():.1f} temporadas')
axes[1, 1].legend()

plt.tight_layout()
plt.show()

print(f"\nüìä ESTAD√çSTICAS DE DURACI√ìN:")
print(f"   Pel√≠cula promedio: {movies_df['duration_min'].mean():.0f} minutos")
print(f"   Pel√≠cula m√°s corta: {movies_df['duration_min'].min():.0f} minutos")
print(f"   Pel√≠cula m√°s larga: {movies_df['duration_min'].max():.0f} minutos")
print(f"   Serie promedio: {tv_shows_df['seasons'].mean():.1f} temporadas")
print(f"   Serie m√°s larga: {tv_shows_df['seasons'].max():.0f} temporadas")
```

# An√°lisis de Visualizaciones y Estrategia de Contenido


## ¬øQu√© tipo de visualizaci√≥n es m√°s efectiva para mostrar distribuciones temporales?
**PISTA:** Compara *line plot* vs *area plot* vs *bar plot*  

El **line plot** es el m√°s efectivo para mostrar distribuciones temporales porque permite visualizar claramente tendencias, picos y ca√≠das a lo largo del tiempo.


## ¬øPor qu√© usamos diferentes tipos de gr√°ficos para diferentes datos?
**PISTA:** Gu√≠a de tipos de gr√°ficos  

Porque cada tipo de gr√°fico representa diferentes relaciones compatibles con distintos datos:

- Barras: ideales para comparar cantidades entre categor√≠as.  
- L√≠neas: muestran tendencias y cambios a lo largo del tiempo.  
- √Årea: enfatizan acumulaciones o proporciones.  
- Heatmaps: revelan patrones y correlaciones entre variables.  


## ¬øQu√© insights de negocio obtuviste que Netflix podr√≠a usar?
**PISTA:** Piensa en estrategias de contenido, mercados objetivo, tipos de producci√≥n  

- El crecimiento acelerado de lanzamientos desde 2015 sugiere una estrategia de expansi√≥n de cat√°logo. ‚Üí Evidencia: gr√°fica de lanzamientos por tipo y a√±o.  
- La mayor√≠a del contenido proviene de EE.UU., India y Reino Unido, lo que indica mercados clave. ‚Üí Evidencia: TOP 15 pa√≠ses con mayor contenido.  
- Los g√©neros m√°s populares y los ratings m√°s comunes pueden guiar adquisiciones y producci√≥n.  
- Co-producciones destacadas:  
  - EE.UU. con Reino Unido (185) y Canad√° (137).  
  - Reino Unido con Francia (37) y Alemania (33).  
  - Francia como socio europeo fuerte con v√≠nculos hacia Reino Unido, Alemania, Espa√±a (15) y Canad√° (21).  


## ¬øCu√°l fue la visualizaci√≥n m√°s reveladora y por qu√©?
**PISTA:** ¬øQu√© patr√≥n no esperabas ver?  

- El heatmap de lanzamientos por d√©cada y tipo fue revelador, mostrando el cambio de enfoque de pel√≠culas a series en la √∫ltima d√©cada.  
- El √°rea plot temporal evidenci√≥ el boom de lanzamientos recientes.  


## ¬øC√≥mo mejorar√≠as este an√°lisis con m√°s datos?
**PISTA:** Datos de audiencia, ratings de IMDb, presupuestos, etc.  

- Conexi√≥n con APIs externas (IMDb, Rotten Tomatoes) para evaluar calidad y recepci√≥n.  
- Incluir presupuestos y gastos de producci√≥n para analizar rentabilidad.  
- Incorporar datos de visualizaciones para medir el impacto real de cada t√≠tulo.  

```python
# === PROFILING AUTOM√ÅTICO DEL DATASET ===
import pandas as pd
import os

# 1. Instalar ydata-profiling (si no est√° instalado)
import sys
print(sys.version)  # deber√≠a mostrar 3.12.x

!{sys.executable} -m pip install -U "ydata-profiling[notebook]"

# 1.1 Cargar dataset desde GitHub
df = pd.read_csv(
    "https://raw.githubusercontent.com/swapnilg4u/Netflix-Data-Analysis/refs/heads/master/netflix_titles.csv")
print("‚úÖ Dataset cargado:", df.shape, "filas y columnas")
display(df.head())

from ydata_profiling import ProfileReport  # clase principal para generar reportes

from ydata_profiling import ProfileReport
profile = ProfileReport(df, title="Netflix Dataset - EDA Report", explorative=True)
profile.to_file("netflix_eda_report.html")
profile

# 2. Importar y generar el reporte
import pandas as pd

print("ü§ñ Generando reporte autom√°tico de EDA...")

# 3. Crear perfil del dataset
from ydata_profiling import ProfileReport  # clase principal para generar reportes

profile = ProfileReport(df, title="Netflix Dataset - EDA Report", explorative=True)  # funci√≥n principal para crear perfil

# 4. Personalizar el reporte
profile.config.html.minify_html = False  # HTML m√°s legible
profile.config.html.use_local_assets = True  # usar assets locales

# 5. Generar reporte HTML
profile.to_file("netflix_eda_report.html")  # m√©todo para guardar reporte como HTML


out_path = os.path.abspath("netflix_eda_report.html")
print(f"üåê El HTML para acceder al reporte es: {out_path}")

profile
```